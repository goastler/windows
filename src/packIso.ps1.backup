# #Requires -RunAsAdministratorparam(    [Parameter(Mandatory = $true)]    [ValidateScript({        if (-not (Test-Path $_ -PathType Leaf)) {            throw "Input ISO file does not exist: $_"        }        if ($_ -notmatch '\.iso$') {            throw "Input file must have .iso extension: $_"        }        $true    })]    [string]$InputIso,    [Parameter(Mandatory = $true)]    [ValidateScript({        $parentDir = Split-Path $_ -Parent        if (-not (Test-Path $parentDir -PathType Container)) {            throw "Output directory does not exist: $parentDir"        }        if ($_ -notmatch '\.iso$') {            throw "Output file must have .iso extension: $_"        }        $true    })]    [string]$OutputIso,    [Parameter(Mandatory = $false)]    [ValidateScript({        if (-not (Test-Path $_ -PathType Leaf)) {            throw "Autounattend XML file does not exist: $_"        }        $true    })]    [string]$AutounattendXml = (Join-Path $PSScriptRoot "autounattend.xml"),    [Parameter(Mandatory = $false)]    [string]$OemDirectory = (Join-Path (Split-Path $PSScriptRoot -Parent) '$OEM$'),    [Parameter(Mandatory = $false)]    [string]$WorkingDirectory = "C:\WinIsoRepack_$(Get-Date -Format 'yyyyMMdd_HHmmss')",    [Parameter(Mandatory = $false)]    [switch]$KeepWorkingDirectory,    [Parameter(Mandatory = $false)]    [switch]$IncludeVirtioDrivers,    [Parameter(Mandatory = $false)]    [ValidateSet("stable", "latest")]    [string]$VirtioVersion = "stable",    [Parameter(Mandatory = $false)]    [string]$VirtioCacheDirectory = (Join-Path $env:TEMP "virtio-cache"))$ErrorActionPreference = "Stop"function Invoke-WebRequestWithCleanup {    param(        [string]$Uri,        [string]$OutFile,        [string]$Description = "download file",        [int]$ProgressId = 3    )        Write-Log "Downloading $Description from: $Uri" "White" 0        $webRequest = $null    try {        # Create a web client for progress tracking        $webClient = New-Object System.Net.WebClient                # Set up progress tracking        $totalBytes = 0        $downloadedBytes = 0                # Register for download progress        Register-ObjectEvent -InputObject $webClient -EventName "DownloadProgressChanged" -Action {            $global:downloadProgress = $Event.SourceEventArgs        } | Out-Null                # Get file size first        try {            $headRequest = [System.Net.WebRequest]::Create($Uri)            $headRequest.Method = "HEAD"            $response = $headRequest.GetResponse()            $totalBytes = $response.ContentLength            $response.Close()        } catch {            Write-Log "Could not determine file size, progress tracking may be limited" "Yellow" 0        }                # Start download with progress tracking        $downloadTask = $webClient.DownloadFileTaskAsync($Uri, $OutFile)                # Monitor progress        while (-not $downloadTask.IsCompleted) {            Start-Sleep -Milliseconds 100                        if ($global:downloadProgress) {                $percentComplete = if ($totalBytes -gt 0) {                    [math]::Round(($global:downloadProgress.BytesReceived / $totalBytes) * 100)                } else {                    [math]::Round(($global:downloadProgress.BytesReceived / ($global:downloadProgress.BytesReceived + 1)) * 100)                }                                $downloadedMB = [math]::Round($global:downloadProgress.BytesReceived / 1MB, 2)                $totalMB = if ($totalBytes -gt 0) { [math]::Round($totalBytes / 1MB, 2) } else { "Unknown" }                                Write-ProgressWithPercentage -Activity "Downloading $Description" -Status "Downloaded $downloadedMB MB of $totalMB MB" -PercentComplete $percentComplete -Id $ProgressId            }        }                # Wait for completion and handle any exceptions        $downloadTask.Wait()        if ($downloadTask.Exception) {            throw "Download failed: $($downloadTask.Exception.Message)"        }                Write-Progress -Activity "Downloading $Description" -Completed -Id $ProgressId        Write-Host "" # Clear the progress line        Write-Log "$Description downloaded successfully" "Green" 0    }    finally {        # Clean up event subscription        try {            Get-EventSubscriber | Where-Object { $_.SourceObject -eq $webClient } | Unregister-Event        } catch {            # Ignore cleanup errors        }                # Properly dispose of web client        if ($webClient) {            try {                $webClient.Dispose()            }            catch {                # Ignore disposal errors            }        }                # Properly dispose of web request object        if ($webRequest) {            try {                $webRequest.Dispose()            }            catch {                # Ignore disposal errors            }        }                # Force garbage collection to ensure resources are released        [System.GC]::Collect()        [System.GC]::WaitForPendingFinalizers()                # Brief pause to ensure file handles are released        Start-Sleep -Seconds 1    }}function Write-Log {    param(        [string]$Message,        [string]$Color = "White",        [int]$Indent = 0    )        $indentString = "  " * $Indent    $fullMessage = $indentString + $Message    Write-Host $fullMessage -ForegroundColor $Color}function Test-Administrator {    $currentUser = [Security.Principal.WindowsIdentity]::GetCurrent()    $principal = New-Object Security.Principal.WindowsPrincipal($currentUser)    return $principal.IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)}function Find-OscdimgPath {    $adkPaths = @(        "${env:ProgramFiles(x86)}\Windows Kits\10\Assessment and Deployment Kit\Deployment Tools\amd64\Oscdimg\oscdimg.exe",        "${env:ProgramFiles}\Windows Kits\10\Assessment and Deployment Kit\Deployment Tools\amd64\Oscdimg\oscdimg.exe",        "${env:ProgramFiles(x86)}\Windows Kits\8.1\Assessment and Deployment Kit\Deployment Tools\amd64\Oscdimg\oscdimg.exe",        "${env:ProgramFiles}\Windows Kits\8.1\Assessment and Deployment Kit\Deployment Tools\amd64\Oscdimg\oscdimg.exe"    )        foreach ($path in $adkPaths) {        if (Test-Path $path) {            Write-Log "Found oscdimg.exe at: $path" "Green" 0            return $path        }    }        throw "oscdimg.exe not found. Please ensure Windows ADK (Assessment and Deployment Kit) is properly installed. The script will attempt to install it automatically, but manual installation may be required."}function Test-RequiredTools {    Write-Log "Checking and installing required tools..." "Yellow" 0        # Install Windows ADK via Chocolatey (it won't reinstall if already present)    Install-WindowsADK        # Find oscdimg.exe path    $script:oscdimgPath = Find-OscdimgPath        # Ensure DISM is available    Test-DismAvailability}function Find-DismInPath {    $dismCommand = Get-Command "dism.exe" -ErrorAction SilentlyContinue    if ($dismCommand) {        Write-Log "DISM found at: $($dismCommand.Source)" "Green" 0        return $true    }    return $false}function Find-DismInStandardLocations {    $dismPaths = @(        "${env:SystemRoot}\System32\dism.exe",        "${env:SystemRoot}\SysWOW64\dism.exe"    )        foreach ($path in $dismPaths) {        if (Test-Path $path) {            Write-Log "DISM found at: $path" "Green" 1            # Add to PATH for current session if not already there            $dismDir = Split-Path $path -Parent            if ($env:Path -notlike "*$dismDir*") {                $env:Path += ";$dismDir"                Write-Log "Added DISM directory to PATH: $dismDir" "Cyan" 2            }            return $true        }    }    return $false}function Enable-DismViaWindowsFeatures {    Write-Log "DISM not found in standard locations. Attempting to enable via Windows Features..." "Yellow" 0    try {        # Try to enable DISM via DISM itself (ironic but sometimes works)        $result = Start-Process -FilePath "dism.exe" -ArgumentList "/?" -Wait -PassThru -NoNewWindow -ErrorAction SilentlyContinue        if ($result.ExitCode -eq 0) {            Write-Log "DISM is now available" "Green" 1            return $true        }    } catch {        # DISM is not available, try alternative approaches    }        # Try to enable via PowerShell    try {        Write-Log "Attempting to enable DISM via PowerShell..." "Yellow" 1        Enable-WindowsOptionalFeature -Online -FeatureName "Deployment-Tools-Foundation" -NoRestart -ErrorAction SilentlyContinue | Out-Null        Enable-WindowsOptionalFeature -Online -FeatureName "Deployment-Tools-Foundation-FoD" -NoRestart -ErrorAction SilentlyContinue | Out-Null                # Check again        $dismCommand = Get-Command "dism.exe" -ErrorAction SilentlyContinue        if ($dismCommand) {            Write-Log "DISM enabled successfully at: $($dismCommand.Source)" "Green" 2            return $true        }    } catch {        Write-Log "Failed to enable DISM via PowerShell: $($_.Exception.Message)" "Yellow" 1    }        return $false}function Install-DismViaChocolatey {    try {        Write-Log "Attempting to install DISM via Chocolatey..." "Yellow" 1        Install-Chocolatey                $result = Start-Process -FilePath "choco" -ArgumentList @("install", "windows-adk-deployment-tools", "-y") -Wait -PassThru -NoNewWindow        if ($result.ExitCode -eq 0) {            Write-Log "Windows ADK Deployment Tools installed via Chocolatey" "Green" 2                        # Refresh PATH            $env:Path = [System.Environment]::GetEnvironmentVariable('Path','Machine') + ';' + `                        [System.Environment]::GetEnvironmentVariable('Path','User')                        # Check again            $dismCommand = Get-Command "dism.exe" -ErrorAction SilentlyContinue            if ($dismCommand) {                Write-Log "DISM now available at: $($dismCommand.Source)" "Green" 3                return $true            }        }    } catch {        Write-Log "Failed to install DISM via Chocolatey: $($_.Exception.Message)" "Yellow" 1    }        return $false}function Test-DismAvailability {    Write-Log "Checking DISM availability..." "Yellow" 0        # Try different methods to find or install DISM    if (Find-DismInPath) { return }    if (Find-DismInStandardLocations) { return }    if (Enable-DismViaWindowsFeatures) { return }    if (Install-DismViaChocolatey) { return }        # If we get here, DISM is not available    Write-Log "ERROR: DISM is not available and could not be installed automatically." "Red" 0    Write-Log "DISM is required for VirtIO driver integration." "Red" 0    Write-Log "Please ensure you are running on Windows 7 or later, or install Windows ADK manually." "Red" 0    throw "DISM (Deployment Image Servicing and Management) is not available and could not be installed automatically. DISM is required for VirtIO driver integration. Please ensure you are running on Windows 7 or later, or install Windows ADK manually."}function Test-Chocolatey {    return (Get-Command "choco" -ErrorAction SilentlyContinue) -ne $null}function Install-Chocolatey {    if (Test-Chocolatey) {        Write-Log "[OK] Chocolatey already installed!" "Green" 1        return    }    Write-Log "Installing Chocolatey package manager..." "Yellow" 0    Set-ExecutionPolicy Bypass -Scope Process -Force    [System.Net.ServicePointManager]::SecurityProtocol = `        [System.Net.ServicePointManager]::SecurityProtocol -bor 3072    iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))        Start-Sleep -Seconds 1    if (Test-Chocolatey) {        Write-Log "[OK] Chocolatey installed successfully!" "Green" 1        return    } else {        throw "Chocolatey installation failed to become available on PATH. Please try running the script again or install Chocolatey manually from https://chocolatey.org/install."                }}function Install-WindowsADK {    Write-Log "=== Windows ADK Installation ===" "Cyan" 0    Install-Chocolatey    Write-Log "Installing Windows ADK via Chocolatey..." "Yellow" 0    $result = Start-Process -FilePath "choco" -ArgumentList @("install","windows-adk","-y") -Wait -PassThru -NoNewWindow    if ($result.ExitCode -eq 0) {        Write-Log "[OK] Windows ADK installed successfully via Chocolatey!" "Green" 1                # Add ADK paths to current session PATH        $adkPaths = @(            "${env:ProgramFiles(x86)}\Windows Kits\10\Assessment and Deployment Kit\Deployment Tools\amd64\Oscdimg",            "${env:ProgramFiles}\Windows Kits\10\Assessment and Deployment Kit\Deployment Tools\amd64\Oscdimg",            "${env:ProgramFiles(x86)}\Windows Kits\8.1\Assessment and Deployment Kit\Deployment Tools\amd64\Oscdimg",            "${env:ProgramFiles}\Windows Kits\8.1\Assessment and Deployment Kit\Deployment Tools\amd64\Oscdimg"        )                foreach ($path in $adkPaths) {            if (Test-Path $path) {                $env:Path += ";$path"                Write-Log "Added to PATH: $path" "Cyan" 2            }        }                # Refresh environment variables        $env:Path = [System.Environment]::GetEnvironmentVariable('Path','Machine') + ';' + `                    [System.Environment]::GetEnvironmentVariable('Path','User')        return    }    throw "Windows ADK installation failed. Please check your internet connection and try again, or install Windows ADK manually from Microsoft's website."}function Extract-IsoContents {    param(        [string]$IsoPath,        [string]$ExtractPath    )        Write-Log "Mounting ISO: $IsoPath" "Yellow" 0    $mountResult = Mount-DiskImage -ImagePath $IsoPath -PassThru    $driveLetter = ($mountResult | Get-Volume).DriveLetter        if (-not $driveLetter) {        throw "Failed to mount ISO file or get drive letter. Please ensure the ISO file is not corrupted and is accessible."    }        $mountedPath = "${driveLetter}:\"    Write-Log "ISO mounted at: $mountedPath" "Green" 0        try {        Write-Log "Extracting ISO contents to: $ExtractPath" "Yellow" 1                if (Test-Path $ExtractPath) {            Remove-Item $ExtractPath -Recurse -Force        }        New-Item -ItemType Directory -Path $ExtractPath -Force | Out-Null                robocopy $mountedPath $ExtractPath /E /COPY:DT /R:3 /W:10 /NFL /NDL /NJH /NJS /nc /ns /np                if ($LASTEXITCODE -gt 7) {            throw "Failed to extract ISO contents. Robocopy exit code: $LASTEXITCODE. Please ensure you have sufficient disk space and the ISO file is not corrupted."        }        Write-Log "ISO contents extracted successfully" "Green" 1    } finally {        Write-Log "Dismounting ISO..." "Yellow" 1        Dismount-DiskImage -ImagePath $IsoPath        Write-Log "ISO dismounted" "Green" 1    }}function Add-AutounattendXml {    param(        [string]$ExtractPath,        [string]$AutounattendXmlPath    )    Write-Log "Adding autounattend.xml to ISO contents..." "Yellow" 0    $destinationPath = Join-Path $ExtractPath "autounattend.xml"    Copy-Item $AutounattendXmlPath $destinationPath -Force    Write-Log "autounattend.xml added to: $destinationPath" "Green" 0}function Add-OemDirectory {    param(        [string]$ExtractPath,        [string]$OemSourcePath    )    Write-Log "Adding $OEM$ directory to ISO contents..." "Yellow" 0        if (-not (Test-Path $OemSourcePath -PathType Container)) {        Write-Log "Warning: $OEM$ directory not found at: $OemSourcePath" "Yellow" 1        return    }        $destinationPath = Join-Path $ExtractPath '$OEM$'        # Remove existing $OEM$ directory if it exists    if (Test-Path $destinationPath) {        Remove-Item $destinationPath -Recurse -Force    }        # Copy the entire $OEM$ directory structure    Copy-Item $OemSourcePath $destinationPath -Recurse -Force    Write-Log "$OEM$ directory added to: $destinationPath" "Green" 0}function New-IsoFromDirectory {    param(        [string]$SourcePath,        [string]$OutputPath,        [string]$OscdimgPath    )    Write-Log "Creating new ISO from directory: $SourcePath" "Yellow" 0    # Resolve absolute paths    $absSrc    = (Resolve-Path $SourcePath).ProviderPath    $absOutDir = (Resolve-Path (Split-Path $OutputPath -Parent)).ProviderPath    $absOutIso = Join-Path $absOutDir (Split-Path $OutputPath -Leaf)    $etfsbootPath  = "$absSrc\boot\etfsboot.com"    $efisysPath    = "$absSrc\efi\microsoft\boot\efisys.bin"    Write-Log "Using source directly: $absSrc" "Cyan" 0    $arguments = @(        "-m"        "-u2"        "-udfver102"        "-bootdata:2#p0,e,b`"$etfsbootPath`"#pEF,e,b`"$efisysPath`""        "`"$absSrc`""        "`"$absOutIso`""    )    Write-Log "Current working directory: $(Get-Location)" "Cyan" 0    Write-Log "Running oscdimg with arguments: $($arguments -join ' ')" "Cyan" 0    Write-Log "Full command: & `"$OscdimgPath`" $($arguments -join ' ')" "Cyan" 0        & $OscdimgPath $arguments    if ($LASTEXITCODE -ne 0) { throw "oscdimg failed to create ISO with exit code: $LASTEXITCODE. Please check that you have sufficient disk space and the source directory is accessible." }    Write-Log "ISO created successfully: $absOutIso" "Green" 0}function Remove-WorkingDirectory {    param([string]$Path)    if (-not $KeepWorkingDirectory -and (Test-Path $Path)) {        Write-Log "Cleaning up working directory: $Path" "Yellow" 1        Remove-Item $Path -Recurse -Force        Write-Log "Working directory cleaned up" "Green" 1    } elseif ($KeepWorkingDirectory) {        Write-Log "Keeping working directory: $Path" "Cyan" 1    }}function Get-VirtioDownloadUrl {    param([string]$Version)        $urls = @{        "stable" = "https://fedorapeople.org/groups/virt/virtio-win/direct-downloads/stable-virtio/virtio-win.iso"        "latest" = "https://fedorapeople.org/groups/virt/virtio-win/direct-downloads/latest-virtio/virtio-win.iso"    }        return $urls[$Version]}function Get-VirtioDrivers {    param(        [string]$Version,        [string]$CacheDirectory    )        Write-Log "=== VirtIO Drivers Download ===" "Cyan" 0        # Create cache directory if it doesn't exist    if (-not (Test-Path $CacheDirectory)) {        New-Item -ItemType Directory -Path $CacheDirectory -Force | Out-Null        Write-Log "Created cache directory: $CacheDirectory" "Green" 1    }        $downloadUrl = Get-VirtioDownloadUrl -Version $Version    $fileName = "virtio-win-$Version.iso"    $localPath = Join-Path $CacheDirectory $fileName        # Check if we already have the file    if (Test-Path $localPath) {        Write-Log "VirtIO drivers already cached: $localPath" "Green" 1        return $localPath    }        try {        # Use Invoke-WebRequestWithCleanup for better progress tracking and resource cleanup        Invoke-WebRequestWithCleanup -Uri $downloadUrl -OutFile $localPath -Description "VirtIO drivers ($Version)" -ProgressId 3        Write-Log "VirtIO drivers downloaded successfully" "Green" 1        return $localPath    } catch {        Write-Log "Failed to download VirtIO drivers: $($_.Exception.Message)" "Red" 1        throw "Failed to download VirtIO drivers: $($_.Exception.Message)"    }}function Extract-VirtioDrivers {    param(        [string]$VirtioIsoPath,        [string]$ExtractPath    )        Write-Log "Extracting VirtIO drivers from: $VirtioIsoPath" "Yellow" 0        # Create virtio directory in the ISO extract path    $virtioDir = Join-Path $ExtractPath "virtio"    if (Test-Path $virtioDir) {        Remove-Item $virtioDir -Recurse -Force    }    New-Item -ItemType Directory -Path $virtioDir -Force | Out-Null        try {        # Mount the VirtIO ISO        Write-Log "Mounting VirtIO ISO..." "Yellow" 1        $mountResult = Mount-DiskImage -ImagePath $VirtioIsoPath -PassThru        $driveLetter = ($mountResult | Get-Volume).DriveLetter                if (-not $driveLetter) {            throw "Failed to mount VirtIO ISO file or get drive letter. Please ensure the VirtIO ISO file is not corrupted and is accessible."        }                $mountedPath = "${driveLetter}:\"        Write-Log "VirtIO ISO mounted at: $mountedPath" "Green" 1                try {            # Copy all contents from VirtIO ISO to the virtio directory            Write-Log "Copying VirtIO drivers to: $virtioDir" "Yellow" 2            robocopy $mountedPath $virtioDir /E /COPY:DT /R:3 /W:10 /NFL /NDL /NJH /NJS /nc /ns /np                        if ($LASTEXITCODE -gt 7) {                throw "Failed to copy VirtIO drivers from mounted ISO. Robocopy exit code: $LASTEXITCODE. Please ensure you have sufficient disk space and the VirtIO ISO is not corrupted."            }                        Write-Log "VirtIO drivers extracted successfully" "Green" 2        } finally {            Write-Log "Dismounting VirtIO ISO..." "Yellow" 2            Dismount-DiskImage -ImagePath $VirtioIsoPath            Write-Log "VirtIO ISO dismounted" "Green" 2        }                return $virtioDir    } catch {        Write-Log "Failed to extract VirtIO drivers: $($_.Exception.Message)" "Red" 1        throw "Failed to extract VirtIO drivers: $($_.Exception.Message)"    }}function Prepare-VirtioDrivers {    param(        [string]$VirtioVersion,        [string]$VirtioCacheDirectory,        [string]$ExtractPath    )        Write-Log "Preparing VirtIO drivers..." "Yellow" 1    try {        # Download VirtIO drivers        $virtioIsoPath = Get-VirtioDrivers -Version $VirtioVersion -CacheDirectory $VirtioCacheDirectory                # Extract VirtIO drivers to a temporary directory        $virtioDir = Extract-VirtioDrivers -VirtioIsoPath $virtioIsoPath -ExtractPath $ExtractPath                Write-Log "VirtIO drivers extracted to: $virtioDir" "Green" 1                # Log the driver structure for debugging        $driverDirs = Get-ChildItem -Path $virtioDir -Directory | Select-Object -ExpandProperty Name        Write-Log "Available driver directories: $($driverDirs -join ', ')" "Cyan" 1                return $virtioDir    } catch {        Write-Log "Failed to prepare VirtIO drivers: $($_.Exception.Message)" "Red" 1        Write-Log "Continuing without VirtIO drivers..." "Yellow" 1        return $null    }}function Process-WimFile {    param(        [string]$WimPath,        [string]$WimType,        [string]$DismPath,        [string]$ExtractPath,        [string]$VirtioDir    )        Write-Log "=== Processing $wimType.wim ===" "Cyan" 1        # Get WIM image information    Write-Log "Getting $wimType.wim image information..." "Yellow" 2    $imageInfo = Get-WimImageInfo -WimPath $WimPath -DismPath $DismPath        if (-not $imageInfo -or $imageInfo.Count -eq 0) {        Write-Log "Warning: Could not get $wimType.wim image information" "Yellow" 2        return    }        Write-Log "Found $($imageInfo.Count) image(s) in $wimType.wim" "Green" 2        # Process each image in the WIM    foreach ($image in $imageInfo) {        Process-WimImage -WimPath $WimPath -Image $image -DismPath $DismPath -ExtractPath $ExtractPath -VirtioDir $VirtioDir    }        Write-Log "Completed processing all images in $wimType.wim" "Green" 2}function Process-WimImage {    param(        [string]$WimPath,        [hashtable]$Image,        [string]$DismPath,        [string]$ExtractPath,        [string]$VirtioDir    )        $imageIndex = $Image.Index    $imageName = $Image.Name    $imageDescription = $Image.Description        Write-Log "Processing image $imageIndex`: $imageName" "Yellow" 3    if ($imageDescription) {        Write-Log "Description: $imageDescription" "Cyan" 4    }        try {        # Detect architecture and version for this specific image        $detectedInfo = Get-WimArchitectureAndVersionForImage -WimPath $WimPath -ImageIndex $imageIndex -DismPath $DismPath        $arch = $detectedInfo.Architecture        $version = $detectedInfo.Version                Write-Log "Detected Architecture: $arch" "Green" 4        Write-Log "Detected Version: $version" "Green" 4                # Perform all WIM-related tasks for this image        $taskResults = Execute-WimTasks -WimPath $WimPath -ImageIndex $imageIndex -Arch $arch -Version $version -DismPath $DismPath -ExtractPath $ExtractPath -VirtioDir $VirtioDir                # Log task results        Log-TaskResults -TaskResults $taskResults            } catch {        Write-Log "Error processing image $imageIndex`: $($_.Exception.Message)" "Red" 4        # Continue with next image    }}function Execute-WimTasks {    param(        [string]$WimPath,        [int]$ImageIndex,        [string]$Arch,        [string]$Version,        [string]$DismPath,        [string]$ExtractPath,        [string]$VirtioDir    )        $taskResults = @{}        # Task 1: VirtIO Driver Injection    if ($IncludeVirtioDrivers -and $VirtioDir) {        $taskResults.VirtIO = Invoke-VirtioDriverInjection -WimPath $WimPath -ImageIndex $ImageIndex -VirtioDir $VirtioDir -Arch $Arch -Version $Version -DismPath $DismPath -ExtractPath $ExtractPath    }        # Future tasks can be added here:    # Task 2: Example - Registry modifications    # $taskResults.Registry = Invoke-RegistryModifications -WimPath $WimPath -ImageIndex $ImageIndex -Arch $Arch -Version $Version -DismPath $DismPath -ExtractPath $ExtractPath        # Task 3: Example - File additions    # $taskResults.Files = Invoke-FileAdditions -WimPath $WimPath -ImageIndex $ImageIndex -Arch $Arch -Version $Version -DismPath $DismPath -ExtractPath $ExtractPath        # Task 4: Example - Windows features enablement    # $taskResults.Features = Invoke-WindowsFeaturesModification -WimPath $WimPath -ImageIndex $ImageIndex -Arch $Arch -Version $Version -DismPath $DismPath -ExtractPath $ExtractPath        # Task 5: Example - Custom software installation    # $taskResults.Software = Invoke-SoftwareInstallation -WimPath $WimPath -ImageIndex $ImageIndex -Arch $Arch -Version $Version -DismPath $DismPath -ExtractPath $ExtractPath        return $taskResults}function Log-TaskResults {    param(        [hashtable]$TaskResults    )        foreach ($taskName in $TaskResults.Keys) {        $result = $TaskResults[$taskName]        if ($result.Success) {            Write-Log "$taskName task completed successfully" "Green" 4        } else {            Write-Log "$taskName task failed: $($result.Error)" "Yellow" 4        }    }}function Process-AllWims {    param(        [string]$ExtractPath,        [string]$VirtioVersion,        [string]$VirtioCacheDirectory    )        Write-Log "=== Processing All WIMs ===" "Cyan" 0        # Prepare VirtIO drivers if requested    $virtioDir = $null    if ($IncludeVirtioDrivers) {        $virtioDir = Prepare-VirtioDrivers -VirtioVersion $VirtioVersion -VirtioCacheDirectory $VirtioCacheDirectory -ExtractPath $ExtractPath    }        # Get DISM path    $dismPath = Get-DismPath        # Process each WIM file    $wimTypes = @("boot", "install")    foreach ($wimType in $wimTypes) {        $wimPath = Join-Path $ExtractPath "sources\$wimType.wim"                if (-not (Test-Path $wimPath)) {            if ($wimType -eq "install") {                Write-Log "Warning: install.wim not found at: $wimPath" "Yellow" 1                continue            } else {                throw "$wimType.wim not found at: $wimPath. Please ensure the ISO was extracted correctly and contains the expected WIM files."            }        }                Process-WimFile -WimPath $wimPath -WimType $wimType -DismPath $dismPath -ExtractPath $ExtractPath -VirtioDir $virtioDir    }        Write-Log "Completed processing all WIMs" "Green" 0}function Find-VirtioDriverPath {    param(        [string]$VirtioDir,        [string]$Arch,        [string]$Version    )        $driverPath = Join-Path $VirtioDir $Arch    if (-not (Test-Path $driverPath)) {        return $null    }        $windowsDriverPath = Join-Path $driverPath $Version    if (-not (Test-Path $windowsDriverPath)) {        return $null    }        return $windowsDriverPath}function Invoke-VirtioDriverInjection {    param(        [string]$WimPath,        [int]$ImageIndex,        [string]$VirtioDir,        [string]$Arch,        [string]$Version,        [string]$DismPath,        [string]$ExtractPath    )        Write-Log "Starting VirtIO driver injection..." "Yellow" 5        try {        # Check if VirtIO drivers are available for this architecture/version combination        $driverPath = Find-VirtioDriverPath -VirtioDir $VirtioDir -Arch $Arch -Version $Version                if (-not $driverPath) {            return @{                Success = $false                Error = "No VirtIO drivers found for architecture $Arch and Windows version $Version"            }        }                Write-Log "Using VirtIO drivers from: $driverPath" "Green" 5                # Inject drivers into this specific image        Inject-VirtioDriversIntoImage -WimPath $WimPath -ImageIndex $ImageIndex -DriverPath $driverPath -DismPath $DismPath -ExtractPath $ExtractPath                return @{            Success = $true            Error = $null        }            } catch {        return @{            Success = $false            Error = $_.Exception.Message        }    }}# Example functions showing how future WIM-related tasks can be easily added:function Invoke-RegistryModifications {    param(        [string]$WimPath,        [int]$ImageIndex,        [string]$Arch,        [string]$Version,        [string]$DismPath,        [string]$ExtractPath    )        Write-Log "Starting registry modifications..." "Yellow" 5        try {        # Example: Mount the WIM, modify registry, unmount        # This is just a placeholder - actual implementation would mount the WIM        # and perform registry modifications using reg.exe or PowerShell registry cmdlets                Write-Log "Registry modifications completed" "Green" 5                return @{            Success = $true            Error = $null        }            } catch {        return @{            Success = $false            Error = $_.Exception.Message        }    }}function Invoke-FileAdditions {    param(        [string]$WimPath,        [int]$ImageIndex,        [string]$Arch,        [string]$Version,        [string]$DismPath,        [string]$ExtractPath    )        Write-Log "Starting file additions..." "Yellow" 5        try {        # Example: Mount the WIM, add files, unmount        # This is just a placeholder - actual implementation would mount the WIM        # and copy files to the mounted image                Write-Log "File additions completed" "Green" 5                return @{            Success = $true            Error = $null        }            } catch {        return @{            Success = $false            Error = $_.Exception.Message        }    }}function Invoke-WindowsFeaturesModification {    param(        [string]$WimPath,        [int]$ImageIndex,        [string]$Arch,        [string]$Version,        [string]$DismPath,        [string]$ExtractPath    )        Write-Log "Starting Windows features modification..." "Yellow" 5        try {        # Example: Mount the WIM, enable/disable Windows features, unmount        # This is just a placeholder - actual implementation would mount the WIM        # and use DISM to enable/disable Windows features                Write-Log "Windows features modification completed" "Green" 5                return @{            Success = $true            Error = $null        }            } catch {        return @{            Success = $false            Error = $_.Exception.Message        }    }}function Invoke-SoftwareInstallation {    param(        [string]$WimPath,        [int]$ImageIndex,        [string]$Arch,        [string]$Version,        [string]$DismPath,        [string]$ExtractPath    )        Write-Log "Starting software installation..." "Yellow" 5        try {        # Example: Mount the WIM, install software, unmount        # This is just a placeholder - actual implementation would mount the WIM        # and install software packages using DISM or other tools                Write-Log "Software installation completed" "Green" 5                return @{            Success = $true            Error = $null        }            } catch {        return @{            Success = $false            Error = $_.Exception.Message        }    }}function Get-WimImageInfo {    param(        [string]$WimPath,        [string]$DismPath    )        try {        Write-Log "Getting WIM image information from: $WimPath" "Yellow" 0                # Use DISM to get image information        $result = Start-Process -FilePath $dismPath -ArgumentList @(            "/Get-WimInfo",            "/WimFile:`"$WimPath`""        ) -Wait -PassThru -NoNewWindow -RedirectStandardOutput "temp_wim_info.txt"                if ($result.ExitCode -ne 0) {            Write-Log "Failed to get WIM info (exit code: $($result.ExitCode))" "Yellow" 0            return $null        }                # Parse the output to extract image information        $wimInfo = Get-Content "temp_wim_info.txt" -ErrorAction SilentlyContinue        Remove-Item "temp_wim_info.txt" -ErrorAction SilentlyContinue                $images = @()        $currentImage = $null                foreach ($line in $wimInfo) {            if ($line -match "Index\s*:\s*(\d+)") {                if ($currentImage) {                    $images += $currentImage                }                $currentImage = @{                    Index = [int]$matches[1]                    Name = ""                    Description = ""                }            } elseif ($currentImage -and $line -match "Name\s*:\s*(.+)") {                $currentImage.Name = $matches[1].Trim()            } elseif ($currentImage -and $line -match "Description\s*:\s*(.+)") {                $currentImage.Description = $matches[1].Trim()            }        }                if ($currentImage) {            $images += $currentImage        }                return $images            } catch {        Write-Log "Error getting WIM image info: $($_.Exception.Message)" "Yellow" 0        return $null    }}function Get-DismPath {    # Try to get DISM from PATH first    $dismCommand = Get-Command "dism.exe" -ErrorAction SilentlyContinue    if ($dismCommand) {        return $dismCommand.Source    }        # Check common DISM locations    $dismPaths = @(        "${env:SystemRoot}\System32\dism.exe",        "${env:SystemRoot}\SysWOW64\dism.exe"    )        foreach ($path in $dismPaths) {        if (Test-Path $path) {            return $path        }    }        throw "DISM (Deployment Image Servicing and Management) not found. Please ensure DISM is available on the system. DISM should be included with Windows 7+ or Windows ADK."}function Get-WimArchitectureAndVersionForImage {    param(        [string]$WimPath,        [int]$ImageIndex,        [string]$DismPath    )        # Create temporary mount directory    $mountDir = Join-Path (Split-Path $WimPath -Parent) "detection_mount_$(Get-Random)"    if (Test-Path $mountDir) {        Remove-Item $mountDir -Recurse -Force    }    New-Item -ItemType Directory -Path $mountDir -Force | Out-Null        try {        # Mount the image        Write-Log "Mounting image for detection..." "Yellow" 4        $result = Start-Process -FilePath $DismPath -ArgumentList @(            "/Mount-Wim",            "/WimFile:`"$WimPath`"",            "/Index:$ImageIndex",            "/MountDir:`"$mountDir`""        ) -Wait -PassThru -NoNewWindow                if ($result.ExitCode -ne 0) {            throw "Failed to mount WIM image for architecture/version detection. DISM exit code: $($result.ExitCode). Please ensure the WIM file is not corrupted and DISM is working properly."        }                # Detect architecture from system files        $arch = Get-WimArchitecture -MountDir $mountDir                # Detect Windows version from registry or system files        $version = Get-WimVersion -MountDir $mountDir                # Unmount the image        Write-Log "Unmounting detection image..." "Yellow" 4        $result = Start-Process -FilePath $DismPath -ArgumentList @(            "/Unmount-Wim",            "/MountDir:`"$mountDir`"",            "/Discard"        ) -Wait -PassThru -NoNewWindow                if ($result.ExitCode -ne 0) {            Write-Log "Warning: Failed to unmount detection image (exit code: $($result.ExitCode))" "Yellow" 4        }                return @{            Architecture = $arch            Version = $version        }            } finally {        # Cleanup mount directory        if (Test-Path $mountDir) {            try {                Remove-Item $mountDir -Recurse -Force -ErrorAction SilentlyContinue            } catch {                Write-Log "Warning: Could not clean up detection mount directory: $mountDir" "Yellow" 4            }        }    }}function Get-WimArchitecture {    param(        [string]$MountDir    )        # Check for architecture-specific system files    $system32Path = Join-Path $MountDir "Windows\System32"    $sysWOW64Path = Join-Path $MountDir "Windows\SysWOW64"        # Check for ARM64    if (Test-Path (Join-Path $system32Path "ntoskrnl.exe")) {        # Try to determine if it's ARM64 by checking for ARM-specific files        $armFiles = @(            "hal.dll",            "ntdll.dll"        )                $isArm64 = $true        foreach ($file in $armFiles) {            $filePath = Join-Path $system32Path $file            if (Test-Path $filePath) {                # Use file command or other method to check if it's ARM64                # For now, we'll use a heuristic based on file size and presence                $fileInfo = Get-Item $filePath -ErrorAction SilentlyContinue                if ($fileInfo) {                    # ARM64 files are typically larger than x86 but smaller than amd64                    # This is a rough heuristic - in practice, you might want to use a more sophisticated method                    if ($fileInfo.Length -lt 1MB) {                        $isArm64 = $false                        break                    }                }            }        }                if ($isArm64) {            return "arm64"        }    }        # Check for x86 vs amd64    if (Test-Path $sysWOW64Path) {        # If SysWOW64 exists, it's amd64        return "amd64"    } else {        # If no SysWOW64, it's likely x86        return "x86"    }}function Get-WimVersion {    param(        [string]$MountDir    )        # Try to read from registry hive    $softwareHive = Join-Path $MountDir "Windows\System32\config\SOFTWARE"        if (Test-Path $softwareHive) {        try {            # Load the registry hive            $hiveName = "WIM_SOFTWARE_$(Get-Random)"            $result = Start-Process -FilePath "reg.exe" -ArgumentList @(                "load",                "HKLM\$hiveName",                "`"$softwareHive`""            ) -Wait -PassThru -NoNewWindow                        if ($result.ExitCode -eq 0) {                try {                    # Try to read the Windows version                    $versionKey = "HKLM:\$hiveName\Microsoft\Windows NT\CurrentVersion"                    if (Test-Path $versionKey) {                        $productName = Get-ItemProperty -Path $versionKey -Name "ProductName" -ErrorAction SilentlyContinue                        if ($productName) {                            $productNameValue = $productName.ProductName                            Write-Log "Product Name: $productNameValue" "Cyan" 0                                                        # Determine version based on product name                            if ($productNameValue -like "*Windows 11*") {                                return "w11"                            } elseif ($productNameValue -like "*Windows 10*") {                                return "w10"                            }                        }                                                # Fallback: check CurrentBuild                        $currentBuild = Get-ItemProperty -Path $versionKey -Name "CurrentBuild" -ErrorAction SilentlyContinue                        if ($currentBuild) {                            $buildNumber = [int]$currentBuild.CurrentBuild                            Write-Log "Build Number: $buildNumber" "Cyan" 0                                                        # Windows 11 builds start from 22000                            if ($buildNumber -ge 22000) {                                return "w11"                            } else {                                return "w10"                            }                        }                    }                } finally {                    # Unload the registry hive                    Start-Process -FilePath "reg.exe" -ArgumentList @(                        "unload",                        "HKLM\$hiveName"                    ) -Wait -PassThru -NoNewWindow | Out-Null                }            }        } catch {            Write-Log "Could not read registry hive: $($_.Exception.Message)" "Yellow" 0        }    }        # Fallback: check for Windows 11 specific files    $win11Files = @(        "Windows\System32\oobe\FirstLogonAnim.exe",        "Windows\System32\Windows.UI.Xaml.dll"    )        foreach ($file in $win11Files) {        $filePath = Join-Path $MountDir $file        if (Test-Path $filePath) {            Write-Log "Found Windows 11 indicator: $file" "Cyan" 0            return "w11"        }    }        # Default to Windows 10 if we can't determine    Write-Log "Could not determine Windows version, defaulting to w10" "Yellow" 0    return "w10"}function Inject-VirtioDriversIntoImage {    param(        [string]$WimPath,        [int]$ImageIndex,        [string]$DriverPath,        [string]$DismPath,        [string]$ExtractPath    )        # Create mount directory    $mountDir = Join-Path $ExtractPath "injection_mount_$(Get-Random)"    if (Test-Path $mountDir) {        Remove-Item $mountDir -Recurse -Force    }    New-Item -ItemType Directory -Path $mountDir -Force | Out-Null        try {        # Mount the image        Write-Log "Mounting image for driver injection..." "Yellow" 4        $result = Start-Process -FilePath $DismPath -ArgumentList @(            "/Mount-Wim",            "/WimFile:`"$WimPath`"",            "/Index:$ImageIndex",            "/MountDir:`"$mountDir`""        ) -Wait -PassThru -NoNewWindow                if ($result.ExitCode -ne 0) {            throw "Failed to mount WIM image for driver injection. DISM exit code: $($result.ExitCode). Please ensure the WIM file is not corrupted and DISM is working properly."        }                Write-Log "Successfully mounted image for driver injection" "Green" 4                # Add drivers to the mounted image        Write-Log "Adding VirtIO drivers..." "Yellow" 4        $result = Start-Process -FilePath $DismPath -ArgumentList @(            "/Image:`"$mountDir`"",            "/Add-Driver",            "/Driver:`"$DriverPath`"",            "/Recurse"        ) -Wait -PassThru -NoNewWindow                if ($result.ExitCode -eq 0) {            Write-Log "Successfully added VirtIO drivers" "Green" 4        } else {            Write-Log "Warning: Failed to add drivers (exit code: $($result.ExitCode))" "Yellow" 4        }                # Unmount and commit changes        Write-Log "Unmounting and committing changes..." "Yellow" 4        $result = Start-Process -FilePath $DismPath -ArgumentList @(            "/Unmount-Wim",            "/MountDir:`"$mountDir`"",            "/Commit"        ) -Wait -PassThru -NoNewWindow                if ($result.ExitCode -eq 0) {            Write-Log "Successfully unmounted and committed changes" "Green" 4        } else {            Write-Log "Warning: Failed to unmount image (exit code: $($result.ExitCode))" "Yellow" 4        }            } catch {        Write-Log "Error injecting drivers: $($_.Exception.Message)" "Red" 4        throw "Failed to inject VirtIO drivers into WIM image: $($_.Exception.Message)"    } finally {        # Cleanup mount directory        if (Test-Path $mountDir) {            try {                Remove-Item $mountDir -Recurse -Force -ErrorAction SilentlyContinue            } catch {                Write-Log "Warning: Could not clean up injection mount directory: $mountDir" "Yellow" 4            }        }    }}function Initialize-Script {    param(        [string]$InputIso,        [string]$OutputIso,        [string]$AutounattendXml,        [string]$OemDirectory,        [string]$WorkingDirectory,        [bool]$IncludeVirtioDrivers,        [string]$VirtioVersion,        [string]$VirtioCacheDirectory    )        Write-Log "=== Windows ISO Repack Script ===" "Cyan" 0    Write-Log "Checking administrator privileges..." "Yellow" 0        if (-not (Test-Administrator)) {        Write-Log "ERROR: This script must be run as Administrator!" "Red" 0        throw "This script must be run as Administrator. Please run PowerShell as Administrator and try again."    }        Write-Log "Administrator privileges confirmed" "Green" 0    Write-Log "Input ISO: $InputIso" "White" 0    Write-Log "Output ISO: $OutputIso" "White" 0    Write-Log "Autounattend XML: $AutounattendXml" "White" 0    Write-Log "OEM Directory: $OemDirectory" "White" 0    Write-Log "Working Directory: $WorkingDirectory" "White" 0    Write-Log "Include VirtIO Drivers: $IncludeVirtioDrivers" "White" 0    if ($IncludeVirtioDrivers) {        Write-Log "VirtIO Version: $VirtioVersion" "White" 0        Write-Log "VirtIO Cache Directory: $VirtioCacheDirectory" "White" 0    }        Test-RequiredTools}function Validate-InputFiles {    param(        [string]$InputIso,        [string]$OutputIso,        [string]$AutounattendXml    )        Write-Log "Validating input files..." "Yellow" 0        # Resolve and validate ISO paths    try {        $resolvedInputIso = Resolve-Path $InputIso -ErrorAction Stop        Write-Log "Resolved input ISO path: $resolvedInputIso" "Cyan" 1    } catch {        throw "Cannot resolve input ISO file path: $InputIso. Please check that the file exists and the path is correct. Error: $($_.Exception.Message)"    }        try {        $resolvedOutputIso = Resolve-Path $OutputIso -ErrorAction SilentlyContinue        if (-not $resolvedOutputIso) {            # If path doesn't exist, resolve the parent directory and create the full path            $outputDir = Split-Path $OutputIso -Parent            $outputFile = Split-Path $OutputIso -Leaf            $resolvedOutputDir = Resolve-Path $outputDir -ErrorAction Stop            $resolvedOutputIso = Join-Path $resolvedOutputDir $outputFile        }        Write-Log "Resolved output ISO path: $resolvedOutputIso" "Cyan" 1    } catch {        throw "Cannot resolve output ISO file path: $OutputIso. Please check that the output directory exists and is accessible. Error: $($_.Exception.Message)"    }        if (-not (Test-Path $resolvedInputIso -PathType Leaf)) {        throw "Input ISO file not found: $resolvedInputIso. Please verify the file path and ensure the file exists."    }    if (-not (Test-Path $AutounattendXml -PathType Leaf)) {        throw "Autounattend XML file not found: $AutounattendXml. Please verify the file path and ensure the file exists."    }    Write-Log "Input files validated" "Green" 0        return @{        InputIso = $resolvedInputIso        OutputIso = $resolvedOutputIso    }}function Process-IsoRepack {    param(        [string]$InputIso,        [string]$OutputIso,        [string]$AutounattendXml,        [string]$OemDirectory,        [string]$WorkingDirectory,        [bool]$IncludeVirtioDrivers,        [string]$VirtioVersion,        [string]$VirtioCacheDirectory    )        # Remove existing output ISO if it exists    if (Test-Path $OutputIso) {        Write-Log "Output ISO already exists. Removing..." "Yellow" 0        Remove-Item $OutputIso -Force    }        # Main processing workflow    Extract-IsoContents -IsoPath $InputIso -ExtractPath $WorkingDirectory    Add-AutounattendXml -ExtractPath $WorkingDirectory -AutounattendXmlPath $AutounattendXml    Add-OemDirectory -ExtractPath $WorkingDirectory -OemSourcePath $OemDirectory    Process-AllWims -ExtractPath $WorkingDirectory -VirtioVersion $VirtioVersion -VirtioCacheDirectory $VirtioCacheDirectory    New-IsoFromDirectory -SourcePath $WorkingDirectory -OutputPath $OutputIso -OscdimgPath $script:oscdimgPath}function Finalize-Repack {    param(        [string]$OutputIso    )        if (Test-Path $OutputIso) {        $fileSize = (Get-Item $OutputIso).Length        $fileSizeGB = [math]::Round($fileSize / 1GB, 2)        Write-Log "Output ISO created successfully!" "Green" 0        Write-Log "File size: $fileSizeGB GB" "Green" 0    } else {        throw "Output ISO was not created successfully. Please check the logs above for any errors during the ISO creation process."    }}try {    # Initialize script and validate prerequisites    Initialize-Script -InputIso $InputIso -OutputIso $OutputIso -AutounattendXml $AutounattendXml -OemDirectory $OemDirectory -WorkingDirectory $WorkingDirectory -IncludeVirtioDrivers $IncludeVirtioDrivers -VirtioVersion $VirtioVersion -VirtioCacheDirectory $VirtioCacheDirectory        # Validate input files and resolve paths    $resolvedPaths = Validate-InputFiles -InputIso $InputIso -OutputIso $OutputIso -AutounattendXml $AutounattendXml        # Process the ISO repack    Process-IsoRepack -InputIso $resolvedPaths.InputIso -OutputIso $resolvedPaths.OutputIso -AutounattendXml $AutounattendXml -OemDirectory $OemDirectory -WorkingDirectory $WorkingDirectory -IncludeVirtioDrivers $IncludeVirtioDrivers -VirtioVersion $VirtioVersion -VirtioCacheDirectory $VirtioCacheDirectory        # Finalize and verify the output    Finalize-Repack -OutputIso $resolvedPaths.OutputIso} catch {    Write-Log "Error: $($_.Exception.Message)" "Red" 0    exit 1} finally {    Remove-WorkingDirectory -Path $WorkingDirectory}Write-Log "=== Script completed successfully! ===" "Green" 0
